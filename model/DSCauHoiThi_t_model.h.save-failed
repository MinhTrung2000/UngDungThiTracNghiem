#ifndef DSCAUHOITHI_T_MODEL_H_INCLUDED
#define DSCAUHOITHI_T_MODEL_H_INCLUDED

//Type: AVL tree
class DSCauHoiThi_t {
private:
  static DSCauHoiThi_t *danhSachCauHoiThiHienHanh;

  static const string DEFAULT_FILE_PATH;

  struct Node {
    CauHoiThi key;
    int height;
    Node *left, *right;

		Node() : key(CauHoiThi()), height(1), left(NULL), right(NULL) {}
		Node(const CauHoiThi& k, int h, Node *l, Node *r)
			: key(k), height(h), left(l), right(r) {}
  };

  //ROOT
  Node *root;
  int sz;

  int height(Node *p) {
		return (p == NULL ? 1 : p->height);
	}

	void update(Node *p) {
		assert(p != NULL);
		p->height = 1 + std::max(height(p->left), height(p->right));
	}

	Node *rotateLeft(Node *p) {
		assert(p != NULL);
		assert(p->right != NULL);

		Node *rightP = p->right;
		p->right = rightP->left;
		rightP->left = p;
		update(p);
		update(rightP);
		return rightP;
	}

	Node *rotateRight(Node *p) {
		assert(p != NULL);
		assert(p->left != NULL);

		Node *leftP = p->left;
		p->left = leftP->right;
		leftP->right = p;
		update(p);
		update(leftP);
		return leftP;
	}

	Node *rebalance(Node *p) {
		if (p == NULL) return NULL;

		update(p);
		if (height(p->left) - height(p->right) > 1) {
			if (height(p->left->left) < height(p->left->right))
				p->left = rotateLeft(p->left);
			p = rotateRight(p);
		} else if (height(p->right) - height(p->left) > 1) {
			if (height(p->right->right) < height(p->right->left))
				p->right = rotateRight(p->right);
			p = rotateLeft(p);
		}

		assert(abs(height(p->right) - height(p->left)) <= 1);
		return p;
	}

	Node *insert(Node *p, const CauHoiThi& v) {
		if (p == NULL) {
			p = new Node(v, 1, NULL, NULL);
			return p;
		} else if (v < p->key) {
			p->left = insert(p->left, v);
		} else {
			p->right = insert(p->right, v);
		}
		return rebalance(p);
	}

	Node *minimum(Node *p) {
		if (p != NULL) {
			while (p->left != NULL) p = p->left;
		}
		return p;
	}

	Node *maximum(Node *p) {
		if (p != NULL) {
			while (p->right != NULL) p = p->right;
		}
		return p;
	}

	Node *remove(Node *p, const CauHoiThi& v) {
		if (p == NULL) return NULL;
		if (v < p->key) {
			p->left =  remove(p->left, v);
		} else if (v > p->key) {
			p->right = remove(p->right, v);
		} else if (p->left != NULL && p->right != NULL) {
			p->key = minimum(p->right)->key;
			p->right = remove(p->right, p->key);
		} else {
			Node *oldNode = p;
			p = (p->left != NULL ? p->left : p->right);
			delete oldNode;
			return p;
		}
		return rebalance(p);
	}

  Node *find(const CauHoiThi& v) const {
		Node *p = root;
		while (p != NULL) {
			if (p->key == v) return p;
			if (p->key > v)
				p = p->left;
			else
				p = p->right;
		}
		return NULL;
	}

	//Lay danh sach cau hoi thi theo ma mon
  void layDanhSachCauHoiTheoMon(const string& maMon, Node *p, Vector<CauHoiThi *> &list) {
    if (p == NULL) return;
    layDanhSachCauHoiTheoMon(maMon, p->left, list);
    if (p->key.maMon == maMon) {
      list.push_back(&(p->key));
    }
    layDanhSachCauHoiTheoMon(maMon, p->right, list);
	}

	//Lay toan bo danh sach cau hoi thi
  void layHetDanhSachCauHoi(Node *p, Vector<CauHoiThi *> &list) {
    if (p == NULL) return;
    layHetDanhSachCauHoi(p->left, list);
    list.push_back(&(p->key));
    layHetDanhSachCauHoi(p->right, list);
	}

  //Writing to file
	void writeElement(ofstream& fw, Node *p) {
		if (p == NULL) return;
		writeElement(fw, p->left);
		fw << p->key << '\n';
		writeElement(fw, p->right);
	}

  Node *clone(Node *p) {
		if (p == NULL) return NULL;
		Node *ret = new Node(p->key, p->height, clone(p->left), clone(p->right));
		update(ret);
		return ret;
	}

	void clear(Node *p) {
		if (p == NULL) return;
		clear(p->left);
		clear(p->right);
		delete p;
	}

  DSCauHoiThi_t() : root(NULL), sz(0) {}

public:

	~DSCauHoiThi_t() {
	  clear();
  }

	bool empty() { return root == NULL; }

	void clear() {
		clear(root);
		root = NULL;
		sz = 0;
	}

	void getDataTable(Vector<Vector<string> >& data, Node *p) {
    if (p == NULL) return;
    getDataTable(data, p->left);
    Vector<string> newRow;
    newRow.push_back(StringUtility::to_string(data.size()));
    newRow.push_back(p->key.maMon);
    newRow.push_back(p->key.canModifyFlag ? "Da ra thi" : "");
    data.push_back(newRow);
    getDataTable(data, p->right);
	}

	//Lay du lieu hien thi tren bang
	Vector<Vector<string> > getDataTable() {
    Vector<Vector<string> > res;
    getDataTable(res, root);
	}

	//Lay toan bo danh sach cau hoi thi
	Vector<CauHoiThi *> layHetDanhSachCauHoi() {
    Vector<CauHoiThi *> result;
    layHetDanhSachCauHoi(root, result);
    return result;
  }

	//Lay danh sach cau hoi thi theo ma mon
	Vector<CauHoiThi *> layDanhSachCauHoiTheoMon(const string& maMon, bool randomFlag) {
    Vector<CauHoiThi *> result;
    layDanhSachCauHoiTheoMon(maMon, root, result);

    if (randomFlag) {
      //random-shuffle list
      RandomUtility::randomShuffle(result);
    }

    return result;
	}

	//Xoa het danh sach cau hoi thi
	bool xoaDS() {
    string rep = showOptionDialog("Xac nhan xoa danh sach ngan hang cau hoi thi?", MessageBox_t::WARNING_MESSAGE, MessageBox_t::OK_CANCEL_OPTION);
	  if (rep == "CANCEL") return false;
	  if (empty()) {
      showMessageDialog("Danh sach cau hoi thi rong!", MessageBox_t::ERROR_MESSAGE);
      return false;
	  }
	  clear();
	  return true;
	}

	//Xoa cau hoi thi theo ma mon hoc
  void xoaCauHoiThiTheoMaMon(const string& maMon, Node *p) {
    if (p == NULL) return;
		xoaCauHoiThiTheoMaMon(maMon, p->left);
		if (p->key.maMon == maMon) {
      root = remove(root, p->key);
		}
		xoaCauHoiThiTheoMaMon(maMon, p->right);
  }

  void xoaCauHoiThiTheoMaMon(const string& maMon) {
    xoaCauHoiThiTheoMaMon(maMon, root);
  }

	//Xoa 1 cau hoi thi theo ID
	bool xoaCauHoiThi(const int& id) {
		CauHoiThi ob;
		ob.setId(id);

		Node *p = find(ob);
		if (p == NULL) {
      showMessageDialog("Cau hoi thi khong ton tai. Khong the xoa!", MessageBox_t::ERROR_MESSAGE);
      return false;
		}
		if (p->key.canModifyFlag == false) {
      showMessageDialog("Cau hoi thi da duoc cho ra de thi. Khong the xoa!", MessageBox_t::ERROR_MESSAGE);
      return false;
		}

		root = remove(root, ob);
		--sz;
		showMessageDialog("Xoa cau hoi thi thanh cong!", MessageBox_t::INFORMATION_MESSAGE);
		return true;
	}

	//Them 1 cau hoi thi
	bool themCauHoiThi(const CauHoiThi& newCauHoiThi) {
		root = insert(root, newCauHoiThi);
		++sz;
		showMessageDialog("Them cau hoi thi thanh cong!", MessageBox_t::INFORMATION_MESSAGE);
		return true;
	}

	//Cap nhat 1 cau hoi thi
	bool capNhatCauHoiThi(const int& id, const string& newMaMon, const string& newCauHoi, const Vector<string>& newLuaChon, const char& newDapAn) {
    if (empty()) {
      showMessageDialog("Danh sach cau hoi thi rong. Khong the cap nhat!", MessageBox_t::ERROR_MESSAGE);
      return false;
    }

    CauHoiThi ob;
    ob.setId(id);
    Node *p = find(ob);

    //cau hoi thi chon tu table nen ton tai
    assert(p != NULL);

    return p->key.capNhat(newMaMon, newCauHoi, newLuaChon, newDapAn);
	}

  bool writeData() {
    ofstream fw(DEFAULT_FILE_PATH.c_str());
    if (!fw.good()) {
      fw.close();
      showMessageDialog("Khong the luu du lieu ngan hang de thi!", MessageBox_t::ERROR_MESSAGE);
      return false;
    }

    //Ghi so luong cau hoi
    fw << sz << '\n';

    writeElement(fw, root);

    fw.close();
    showMessageDialog("Luu du lieu ngan hang de thi thanh cong!", MessageBox_t::INFORMATION_MESSAGE);
    return true;
  }

  bool readData() {
    ifstream fr(DEFAULT_FILE_PATH.c_str());
    if (!fr.good()) {
      fr.close();
      showMessageDialog("Khong the tai du lieu ngan hang de thi!", MessageBox_t::ERROR_MESSAGE);
      return false;
    }

    //clear old data
    clear();

    fr >> sz;
    fr.ignore();

    CauHoiThi ob;
    for (int i = 0; i < sz; ++i) {
      fr >> ob;
      root = insert(root, ob);
    }

    fr.close();
    showMessageDialog("Load du lieu ngan hang de thi thanh cong!", MessageBox_t::INFORMATION_MESSAGE);
    return true;
  }

  DSCauHoiThi_t& operator = (const DSCauHoiThi_t& rhs) {
		clear();
		root = clone(rhs.root);
		sz = rhs.sz;
		return *this;
	}

	//===================================================================
	static DSCauHoiThi_t *getDSCauHoiThiHienHanh() { return danhSachCauHoiThiHienHanh; }
};

DSCauHoiThi_t *DSCauHoiThi_t::danhSachCauHoiThiHienHanh = new DSCauHoiThi_t;

const string DSCauHoiThi_t::DEFAULT_FILE_PATH = "data/NganHangDeThi.data";


#endif // DSCAUHOITHI_T_MODEL_H_INCLUDED
